import numpy as np
import rdflib
import shap

from collections import defaultdict


def explain(model, X, kg, prefixes, full_paths, ink_embedding, ink_node, selector=None, type='linear', verbose=False):
    """
    Explain a model using a shap explainer.
    :param model: learning model to be explained.
    :type model: model object
    :param X: dataframe containing all INK embeddings.
    :type X: pandas.DataFrame object
    :param kg: knowledge graph from which dataset features were extracted.
    :type kg: rdflib.Graph object
    :param prefixes: prefix mapping to explain INK prefixes.
    :type prefixes: dict
    :param full_paths: extracted INK paths including intermediary nodes.
    :type full_paths: list
    :param ink_embedding: INK embedding for which model explanations will be generated.
    :type ink_embedding: pandas.DataFrame object
    :param ink_node: graph node corresponding to INK embedding.
    :type ink_node: str
    :param selector: feature selector.
    :type selector: feature selector object
    :param type: type of shap explainer.
    :type type: str
    :param verbose: whether full paths should be extracted.
    :type verbose: bool
    :return: None
    :rtype: N/A
    """
    def shapley_feature_ranking(shap_values, columns, top_n):
        """
        Rank top N features using shap.
        :param shap_values: shap values generated by shap explainer.
        :type shap_values: np.array
        :param columns: list of column names.
        :type columns: list
        :param top_n: number of top features to return.
        :type top_n: int
        """
        if len(shap_values.shape) > 1:
            feature_order = np.argsort(np.mean(np.abs(shap_values), axis=0))
        else:
            feature_order = np.argsort(np.abs(shap_values))
        ranking = {}

        # precompute all possible expanded paths
        expanded_paths = [path.split('¥') for path in full_paths]
        expanded_paths_with_mapping = defaultdict(list)
        for i, sppath in enumerate(expanded_paths):
            expanded_paths[i] = []
            expanded_path_without_object = []
            for subpath in sppath:
                split_subpath = subpath.split('(')
                if len(split_subpath) > 1:
                    expanded_path_without_object.append(split_subpath[0])
                else:
                    expanded_path_without_object.append(subpath)
                for el in split_subpath:
                    expanded_paths[i].append(el.strip(')'))
            expanded_paths_with_mapping['¥'.join(expanded_path_without_object)].append(expanded_paths[i])

        # rank-order features in terms of importance...
        for i, rank in enumerate(feature_order[::-1]):
            if i >= top_n:
                break
            # first expand if desired/possible
            path = columns[rank]
            if verbose and (ink_embedding[columns[rank]] != 0.0).all():
                print("Trying to expand path", path)
                split_path = path.split('.')
                tail_end = None
                if '§' in split_path[-1]:
                    ssplit_path = split_path[-1].split('§')
                    split_path[-1] = ssplit_path[0]
                    # split_path.append(ssplit_path[-1])
                    tail_end = ssplit_path[-1]

                # map path onto path with nodes
                candidates = set(expanded_paths_with_mapping.keys())
                print('Possible candidates:', candidates)
                excluded = set()
                for j, el in enumerate(split_path):
                    for epath in candidates:
                        def expand(el):
                            expanded_el = el
                            for pref in prefixes:
                                expanded_el = expanded_el.replace(pref, prefixes[pref])
                            return expanded_el

                        expanded_el = expand(el)
                        if 'http' not in expanded_el:
                            break
                        # identify impossible candidate paths
                        if j >= len(epath.split('¥')) or epath.split('¥')[j] != expanded_el:
                            excluded.add(epath)
                    candidates -= excluded

                # identify impossible candidate paths
                for epath in candidates:
                    if len(epath.split('¥')) != len(split_path):
                        excluded.add(epath)
                candidates -= excluded

                # if candidates were found...
                if len(list(candidates)) > 0:
                    final_path = expanded_paths_with_mapping[list(candidates)[0]]

                    print('Potential final paths:', final_path)

                    # if final path still not completely determined...
                    if len(final_path) > 1 and isinstance(final_path[0], list):
                        # check if final part corresponds with
                        if tail_end is not None and 'http' in expand(tail_end):
                            for candidate in final_path:
                                if candidate[-1] == expand(tail_end):
                                    final_path = candidate
                                    print('Appropriate candidate found!')
                                    break
                        else:  # if the previous doesn't yield anything...
                            for candidate in final_path:
                                for obj in kg.objects(subject=rdflib.term.URIRef(candidate[-2]), predicate=rdflib.term.URIRef(candidate[-1])):
                                    if str(obj) == tail_end:
                                        final_path = candidate
                                        final_path.append(tail_end)
                                        print('Appropriate candidate found!')
                                        break

                    # only one final candidate was found...
                    elif len(final_path) == 1:
                        final_path = final_path[0]
                        if tail_end is not None and 'http' not in expand(tail_end):
                            final_path.append(tail_end)

                else:
                    print('Path not found for focal node...')
                    final_path = path
            else:
                if verbose:
                    print('Path not found for focal node...')
                final_path = path

            if len(shap_values.shape) > 1:
                print(i, ",", np.mean(np.abs(shap_values), axis=0)[rank], ",", ink_node, final_path)
                ranking[columns[rank]] = np.mean(np.abs(shap_values), axis=0)[rank]
            else:
                print(i, ",", np.abs(shap_values)[rank], ",", ink_node, final_path)
                ranking[columns[rank]] = np.abs(shap_values)[rank]
        return ranking

    # select appropriate explainer...
    if type == 'linear':
        if selector is None:
            masker = shap.maskers.Independent(data=X)
        else:
            masker = shap.maskers.Independent(data=selector.transform(X))
        explainer = shap.LinearExplainer(model, masker=masker)
    elif type == 'tree':
        explainer = shap.TreeExplainer(model)
    else:
        explainer = shap.Explainer(model)

    # apply selector first if available...
    if selector is not None:
        shap_values = explainer.shap_values(selector.transform(ink_embedding))
        resulting_features = list(selector.feature_names_in_[selector._get_support_mask()])
    else:
        shap_values = explainer.shap_values(ink_embedding)
        resulting_features = X.columns
    return shapley_feature_ranking(shap_values, resulting_features, 25)

